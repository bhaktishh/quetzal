type Vect<Ty T>(Nat n) {
    constructor Nil<>() of Vect<T>(0);
    constructor Cons<>(T head, Vect<T>(n) tail) of Vect<T>(n+1);
}
type Pair<Ty T>(Func(T a => Ty) P) {
    constructor MkPair (T a, P snd) of Pair<T>(p);
}

record Pair<Ty T> (Func(T a => Ty) p) {
    T fst; 
    p(fst) snd;
}

func append<Nat n, Nat m, Ty T> (Vect<T>(n) v1, Vect<T>(m) v2) of Vect<T>(n+m) {
    switch (v1, v2) {
        case (Nil(), v2) {
            return v2;
        }
        case (Cons(x, xs), v2) {
            v2 = append(xs, v2);
            return Cons(x, v2);
        }   
    };
}

func test<>() of Void {}

func test2<Ty T> (T a, Nat n) of Vect<n,T>() {
    switch(n) {
        case (0) {;}
        case (1) {;}
    };
}

func replicate<Ty T> (T a, Nat n) of Vect<n,T>() {
    switch(n) {
        case (0) {return Nil();}
        case (S(n)) {return Cons (x, replicate(x,n));}
    };
}

